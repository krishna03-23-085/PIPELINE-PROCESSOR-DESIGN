# PIPELINE-PROCESSOR-DESIGN

*COMPANY*: CODTECH IT SOLUTIONS  

*NAME*: KRISHNA SINGH 

*INTERN ID*: CT04DR278  

*DOMAIN*: VLSI 

*DURATION*: 4 WEEKS  

*MENTOR*: NEELA SANTOSH

##Description 

Objective

The aim of this task was to design, simulate, and analyze the operation of a four-stage pipelined processor using the EDA Playground simulation platform. The primary goal was to understand how instruction pipelining improves processor efficiency by overlapping the execution of multiple instructions and to visualize the working of each stage through waveform analysis.

⸻

Tool Used: EDA Playground

EDA Playground is an online HDL (Hardware Description Language) simulation environment that allows users to write, compile, and execute Verilog or SystemVerilog code without needing any external software installation. It integrates popular simulation tools such as Icarus Verilog, Verilator, and Aldec Riviera-PRO, and provides a waveform viewer called EPWave for analyzing signal transitions over time.

For this experiment, the simulator used was Icarus Verilog, as it is lightweight, fast, and fully compatible with standard Verilog syntax. The testbench and design were written in two separate files — design.sv (processor module) and testbench.sv (clock and control logic). The simulation results were visualized using EPWave to observe how instructions propagate through the four pipeline stages.

⸻

Design Description

The processor architecture consisted of four main pipeline stages:
	1.	Instruction Fetch (IF): The instruction is fetched from memory using the program counter (PC).
	2.	Instruction Decode (ID): The fetched instruction is decoded to identify the opcode and register operands.
	3.	Execution (EX): The Arithmetic Logic Unit (ALU) performs the required operation such as addition, subtraction, or load.
	4.	Write Back (WB): The final result is written back into the destination register.

The processor included a register file, an instruction memory, a data memory, and pipeline registers between stages to hold intermediate values. The instruction set used basic operations like ADD, SUB, and LOAD. Each instruction was represented in binary format and stored in instruction memory before simulation began.

⸻

Working Principle

The clock signal (clk) generated by the testbench acted as the synchronization source for all operations. On each positive clock edge, the instruction moved from one stage to the next, creating an overlapping execution effect.

Initially, only one instruction entered the pipeline (Fetch stage). In the next cycle, the first instruction moved to Decode while a second instruction was fetched. After a few cycles, all stages were filled, and multiple instructions were being processed concurrently — one in each stage. This overlapping execution significantly improves processor throughput, completing one instruction per clock cycle after the pipeline fill-up.

The testbench included the $dumpfile("dump.vcd"); and $dumpvars; commands to generate the waveform file (dump.vcd), which allowed EPWave to display signal transitions graphically.

⸻

Simulation and Waveform Analysis

After running the simulation on EDA Playground, the waveform displayed signals such as clk, PC, IF_ID_IR, ID_EX_IR, EX_WB_IR, and EX_WB_ALUOUT.
	•	clk showed a regular square wave toggling every few time units.
	•	PC incremented steadily, confirming that the program counter was fetching sequential instructions.
	•	IF_ID_IR, ID_EX_IR, and EX_WB_IR showed staggered instruction movement through each pipeline stage.
	•	EX_WB_ALUOUT displayed arithmetic results generated by the ALU during the Execute stage and written back in the Write-Back stage.

The waveform clearly demonstrated instruction overlap, proving that the design implemented pipelining correctly. Each stage completed its operation in one clock cycle, and new results appeared at regular intervals as expected.

#Result

<img width="1440" height="846" alt="Image" src="https://github.com/user-attachments/assets/9c78d90b-c4ed-4aa6-842c-6a50c99b3177" />
